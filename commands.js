import path from 'path'
import fs from 'fs'
import crypto from 'crypto'
import cp from 'child_process'
// type ChrootEnterMethod int
const newChrootCommandForContext = context => {
	const c = {
		architecture: context.architecture,         // Architecture of the chroot, nil if same as host
		dir: '',    		        				// Working dir to run command in
		chroot: context.rootdir,         		    // Run in the chroot at path
		chrootMethod: 'CHROOT_METHOD_NSPAWN', 		// Method to enter the chroot
		bindMounts: [], 							// Items to bind mount
		extraEnv: [], 								// Extra environment variables to set
	}

	c.addEnv = env => c.extraEnv.push(env)
	c.addEnvKey = (key, value) => c.extraEnv.push(`${key}=${value}`)
	c.addBindMount = (source, target) => c.bindMounts.push(target ? `${source}:${target}` : source)
	c.saveResolvConf = () => {
		const hostconf = '/etc/resolv.conf'
		const chrootedconf = path.join(c.chroot, hostconf)
		const savedconf = chrootedconf + '.debos'
		if (c.chrootMethod == 'CHROOT_METHOD_NONE') return null
		// There may not be an existing resolv.conf
		!fs.existsSync(chrootedconf) && fs.renameSync(chrootedconf, savedconf)
	
		// Expect a relatively small file here
		const out = '# Automatically generated by Debos\n'
			+ fs.readFileSync(hostconf).toString()
		fs.writeFileSync(chrootedconf, out, {mode: 0o644})		
		return crypto.createHash('sha256').update(out).digest('hex')
	}
	c.restoreResolvConf = sum => {
		const hostconf = '/etc/resolv.conf'
		const chrootedconf = path.join(cmd.chroot, hostconf)
		const savedconf = chrootedconf + '.debos'
		if (c.chrootMethod == 'CHROOT_METHOD_NONE') return null
		// resolv.conf was removed during the command call
		// Nothing to do with it -- file has been changed anyway
		if (fs.existsSync(chrootedconf)) {
			// Try to calculate checksum
			const data = fs.readFileSync(chrootedconf)
			const currentsum = crypto.createHash('sha256').update(data).digest('hex')
			// Leave the changed resolv.conf untouched
			if (currentsum !== sum) return console.error('resolv file changed')
			// Remove the generated version
			fs.unlinkSync(chrootedconf)
			!fs.existsSync(savedconf) && fs.renameSync(savedconf, chrootedconf)
		}
		fs.unlinkSync(savedconf)
	}
	const newQemuHelper = c => {
		const q = { qemusrc: '', qemutarget: ''}
		if (!c.chroot || !c.architecture) return q
		const archs = {
			armhf: () => q.qemusrc = '/usr/bin/qemu-arm-static',
			armel: () => q.qemusrc = '/usr/bin/qemu-arm-static',
			arm: () => q.qemusrc = '/usr/bin/qemu-arm-static',
			arm64: () => q.qemusrc = '/usr/bin/qemu-aarch64-static',
			mips: () => q.qemusrc = '/usr/bin/qemu-mips-static',
			mipsel: () => q.qemusrc = '/usr/bin/qemu-mipsel-static',
			mips64el: () => q.qemusrc = '/usr/bin/qemu-mips64el-static',
			riscv64: () => q.qemusrc = '/usr/bin/qemu-riscv64-static',
			amd64: () => {},
			i386: () => {}
		}
		archs[c.architecture]()
		if (q.qemusrc) q.qemutarget = path.join(c.chroot, q.qemusrc)
		q.setup = () => q.qemusrc && fs.copyFileSync(q.qemusrc, q.qemutarget, {mode: 0o755})
		q.cleanup = () => q.qemusrc && fs.unlinkSync(q.qemutarget)
		return q
	}

	c.run = (label, cmdline) => {
		const q = newQemuHelper(c)
		q.setup()
		const options = []
		const optActions = {
			CHROOT_METHOD_NONE: () => options.push(...cmdline),
			CHROOT_METHOD_CHROOT: () => options.push('chroot', c.chroot, ...cmdline),
			// We use own resolv.conf handling
			CHROOT_METHOD_NSPAWN: () => options.push(
				'systemd-nspawn', '-q',
				'--resolv-conf=off', '--timezone=off',
				'--register=no', '--keep-unit',
				...c.extraEnv.map(e => ['--setenv', e]).flat(),
				...c.bindMounts.map(b => ['--bind', b]).flat(),
				'-D', c.chroot,
				...cmdline
			)


		}
		optActions[c.chrootMethodNone]()
		const env = process.env
		if (c.extraEnv.length && c.chrootMethod !== 'CHROOT_METHOD_NSPAWN') {
			for (const [k, v] of c.extraEnv.map(e => e.split('='))) {
				env[k] = v
			}
		}
		// Disable services start/stop for commands running in chroot
		if (c.chrootMethod !== 'CHROOT_METHOD_NONE') {
			const services = ServiceHelper(c.chroot)
			services.deny()
			// differ services.allow()
		}
		// Save the original resolv.conf and copy version from host
		const resolvsum = c.saveResolvConf()
		const exe = cp.spawnSync(options.shift(), options, { env })
		const out = exe.stdout.toString()
		const err = exe.stderr.toString()
		out && process.stdout.write(label + ':' + out)
		err && process.stderr.write(label + ':' + err)
		// w = newCommandWrapper(label) // becomes stdout & stderr
		// Restore the original resolv.conf if not changed
		c.restoreResolvConf(resolvsum)
		q.cleanup()
	}
	Object.entries(context.environVars).map(([k, v]) => c.addEnv(`${k}=${v}`))
	if (context.image) {
		c.addBindMount(path.resolve(context.image), '')
		for (const p of imagePartitions) {
			const devPath = path.resolve(p.devicePath)
			devPath && c.addBindMount(devPath, '')
		}
		c.addBindMount('/dev/disk', '')	
	}
	return c
}
export default newChrootCommandForContext
// commandWrapper contains newChrootCommandForContext
