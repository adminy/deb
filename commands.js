import path from 'path'
import fs from 'fs'
import crypto from 'crypto'
import cp from 'child_process'
// type ChrootEnterMethod int
const NewChrootCommandForContext = context => {
	const c = {
		Architecture: context.Architecture,         // Architecture of the chroot, nil if same as host
		Dir: '',    		        				// Working dir to run command in
		Chroot: context.Rootdir,         		    // Run in the chroot at path
		ChrootMethod: 'CHROOT_METHOD_NSPAWN', 		// Method to enter the chroot
		bindMounts: [], 							// Items to bind mount
		extraEnv: [], 								// Extra environment variables to set
	}

	c.AddEnv = env => c.extraEnv.push(env)
	c.AddEnvKey = (key, value) => c.extraEnv.push(`${key}=${value}`)
	c.AddBindMount = (source, target) => c.bindMounts.push(target ? `${source}:${target}` : source)
	c.saveResolvConf = () => {
		const hostconf = '/etc/resolv.conf'
		const chrootedconf = path.join(c.Chroot, hostconf)
		const savedconf = chrootedconf + '.debos'
		if (c.ChrootMethod == 'CHROOT_METHOD_NONE') return null
		// There may not be an existing resolv.conf
		!fs.existsSync(chrootedconf) && fs.renameSync(chrootedconf, savedconf)
	
		// Expect a relatively small file here
		const out = '# Automatically generated by Debos\n'
			+ fs.readFileSync(hostconf).toString()
		fs.writeFileSync(chrootedconf, out, {mode: 0o644})		
		return crypto.createHash('sha256').update(out).digest('hex')
	}
	c.restoreResolvConf = sum => {
		const hostconf = '/etc/resolv.conf'
		const chrootedconf = path.join(cmd.Chroot, hostconf)
		const savedconf = chrootedconf + '.debos'
		if (c.ChrootMethod == 'CHROOT_METHOD_NONE') return null
		// resolv.conf was removed during the command call
		// Nothing to do with it -- file has been changed anyway
		if (fs.existsSync(chrootedconf)) {
			// Try to calculate checksum
			const data = fs.readFileSync(chrootedconf)
			const currentsum = crypto.createHash('sha256').update(data).digest('hex')
			// Leave the changed resolv.conf untouched
			if (currentsum !== sum) return console.error('resolv file changed')
			// Remove the generated version
			fs.unlinkSync(chrootedconf)
			!fs.existsSync(savedconf) && fs.renameSync(savedconf, chrootedconf)
		}
		fs.unlinkSync(savedconf)
	}
	const newQemuHelper = c => {
		const q = { qemusrc: '', qemutarget: ''}
		if (!c.Chroot || !c.Architecture) return q
		const archs = {
			armhf: () => q.qemusrc = '/usr/bin/qemu-arm-static',
			armel: () => q.qemusrc = '/usr/bin/qemu-arm-static',
			arm: () => q.qemusrc = '/usr/bin/qemu-arm-static',
			arm64: () => q.qemusrc = '/usr/bin/qemu-aarch64-static',
			mips: () => q.qemusrc = '/usr/bin/qemu-mips-static',
			mipsel: () => q.qemusrc = '/usr/bin/qemu-mipsel-static',
			mips64el: () => q.qemusrc = '/usr/bin/qemu-mips64el-static',
			riscv64: () => q.qemusrc = '/usr/bin/qemu-riscv64-static',
			amd64: () => {},
			i386: () => {}
		}
		archs[c.Architecture]()
		if (q.qemusrc) q.qemutarget = path.join(c.Chroot, q.qemusrc)
		q.Setup = () => q.qemusrc && fs.copyFileSync(q.qemusrc, q.qemutarget, {mode: 0o755})
		q.Cleanup = () => q.qemusrc && fs.unlinkSync(q.qemutarget)
		return q
	}

	c.Run = (label, cmdline) => {
		const q = newQemuHelper(c)
		q.Setup()
		const options = []
		const optActions = {
			CHROOT_METHOD_NONE: () => options.push(...cmdline),
			CHROOT_METHOD_CHROOT: () => options.push('chroot', c.Chroot, ...cmdline),
			// We use own resolv.conf handling
			CHROOT_METHOD_NSPAWN: () => options.push(
				'systemd-nspawn', '-q',
				'--resolv-conf=off', '--timezone=off',
				'--register=no', '--keep-unit',
				...c.extraEnv.map(e => ['--setenv', e]).flat(),
				...c.bindMounts.map(b => ['--bind', b]).flat(),
				'-D', c.Chroot,
				...cmdline
			)


		}
		optActions[c.ChrootMethodNone]()
		const env = process.env
		if (c.extraEnv.length && c.ChrootMethod !== 'CHROOT_METHOD_NSPAWN') {
			for (const [k, v] of c.extraEnv.map(e => e.split('='))) {
				env[k] = v
			}
		}
		// Disable services start/stop for commands running in chroot
		if (c.ChrootMethod !== 'CHROOT_METHOD_NONE') {
			const services = ServiceHelper(c.Chroot)
			services.Deny()
			// differ services.Allow()
		}
		// Save the original resolv.conf and copy version from host
		const resolvsum = c.saveResolvConf()
		const exe = cp.spawnSync(options.shift(), options, { env })
		const out = exe.stdout.toString()
		const err = exe.stderr.toString()
		out && process.stdout.write(label + ':' + out)
		err && process.stderr.write(label + ':' + err)
		// w = newCommandWrapper(label) // becomes stdout & stderr
		// Restore the original resolv.conf if not changed
		c.restoreResolvConf(resolvsum)
		q.Cleanup()
	}
	Object.entries(context.EnvironVars).map(([k, v]) => c.AddEnv(`${k}=${v}`))
	if (context.Image) {
		c.AddBindMount(path.resolve(context.Image), '')
		for (const p of ImagePartitions) {
			const devPath = path.resolve(p.DevicePath)
			devPath && c.AddBindMount(devPath, '')
		}
		c.AddBindMount('/dev/disk', '')	
	}
	return c
}
export default NewChrootCommandForContext
// commandWrapper contains NewChrootCommandForContext
